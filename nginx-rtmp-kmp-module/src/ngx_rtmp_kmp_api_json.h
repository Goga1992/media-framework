/* auto-generated by generate_json_builder.py */

static size_t
ngx_rtmp_kmp_api_upstream_json_get_size(ngx_kmp_push_upstream_t *obj)
{
    size_t result =
        sizeof("{\"id\":\"") - 1 + obj->id.len + ngx_escape_json(NULL,
            obj->id.data, obj->id.len) +
        sizeof("\",\"remote_addr\":\"") - 1 + obj->remote_addr.len +
            ngx_escape_json(NULL, obj->remote_addr.data, obj->remote_addr.len)
            +
        sizeof("\",\"local_addr\":\"") - 1 + obj->local_addr.len +
            ngx_escape_json(NULL, obj->local_addr.data, obj->local_addr.len) +
        sizeof("\",\"connection\":") - 1 + NGX_INT_T_LEN +
        sizeof("}") - 1;

    return result;
}

static u_char *
ngx_rtmp_kmp_api_upstream_json_write(u_char *p, ngx_kmp_push_upstream_t *obj)
{
    p = ngx_copy(p, "{\"id\":\"", sizeof("{\"id\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, obj->id.data, obj->id.len);
    p = ngx_copy(p, "\",\"remote_addr\":\"", sizeof("\",\"remote_addr\":\"") -
        1);
    p = (u_char *) ngx_escape_json(p, obj->remote_addr.data,
        obj->remote_addr.len);
    p = ngx_copy(p, "\",\"local_addr\":\"", sizeof("\",\"local_addr\":\"") -
        1);
    p = (u_char *) ngx_escape_json(p, obj->local_addr.data,
        obj->local_addr.len);
    p = ngx_copy(p, "\",\"connection\":", sizeof("\",\"connection\":") - 1);
    p = ngx_sprintf(p, "%uA", (ngx_atomic_uint_t) obj->log.connection);
    *p++ = '}';

    return p;
}

static size_t
ngx_rtmp_kmp_api_video_track_json_get_size(ngx_kmp_push_track_t *obj,
    ngx_rtmp_codec_ctx_t *codec_ctx)
{
    ngx_queue_t  *q;
    size_t result =
        sizeof("{\"input_id\":\"") - 1 + obj->input_id.len +
            ngx_escape_json(NULL, obj->input_id.data, obj->input_id.len) +
        sizeof("\",\"channel_id\":\"") - 1 + obj->channel_id.len +
            ngx_escape_json(NULL, obj->channel_id.data, obj->channel_id.len) +
        sizeof("\",\"track_id\":\"") - 1 + obj->track_id.len +
            ngx_escape_json(NULL, obj->track_id.data, obj->track_id.len) +
        sizeof("\",\"mem_left\":") - 1 + NGX_SIZE_T_LEN +
        sizeof(",\"mem_limit\":") - 1 + NGX_SIZE_T_LEN +
        sizeof(",\"codec_info\":") - 1 +
            ngx_rtmp_kmp_api_video_codec_info_json_get_size(codec_ctx) +
        sizeof(",\"upstreams\":[") - 1 +
        sizeof("]}") - 1;

    for (q = ngx_queue_head(&obj->upstreams);
        q != ngx_queue_sentinel(&obj->upstreams);
        q = ngx_queue_next(q))
    {
        ngx_kmp_push_upstream_t *cur = ngx_queue_data(q,
            ngx_kmp_push_upstream_t, queue);
        result += ngx_rtmp_kmp_api_upstream_json_get_size(cur) + sizeof(",") -
            1;
    }

    return result;
}

static u_char *
ngx_rtmp_kmp_api_video_track_json_write(u_char *p, ngx_kmp_push_track_t *obj,
    ngx_rtmp_codec_ctx_t *codec_ctx)
{
    ngx_queue_t  *q;
    p = ngx_copy(p, "{\"input_id\":\"", sizeof("{\"input_id\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, obj->input_id.data, obj->input_id.len);
    p = ngx_copy(p, "\",\"channel_id\":\"", sizeof("\",\"channel_id\":\"") -
        1);
    p = (u_char *) ngx_escape_json(p, obj->channel_id.data,
        obj->channel_id.len);
    p = ngx_copy(p, "\",\"track_id\":\"", sizeof("\",\"track_id\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, obj->track_id.data, obj->track_id.len);
    p = ngx_copy(p, "\",\"mem_left\":", sizeof("\",\"mem_left\":") - 1);
    p = ngx_sprintf(p, "%uz", (size_t) obj->mem_left);
    p = ngx_copy(p, ",\"mem_limit\":", sizeof(",\"mem_limit\":") - 1);
    p = ngx_sprintf(p, "%uz", (size_t) obj->mem_limit);
    p = ngx_copy(p, ",\"codec_info\":", sizeof(",\"codec_info\":") - 1);
    p = ngx_rtmp_kmp_api_video_codec_info_json_write(p, codec_ctx);
    p = ngx_copy(p, ",\"upstreams\":[", sizeof(",\"upstreams\":[") - 1);

    for (q = ngx_queue_head(&obj->upstreams);
        q != ngx_queue_sentinel(&obj->upstreams);
        q = ngx_queue_next(q))
    {
        ngx_kmp_push_upstream_t *cur = ngx_queue_data(q,
            ngx_kmp_push_upstream_t, queue);

        if (q != ngx_queue_head(&obj->upstreams)) {
            *p++ = ',';
        }
        p = ngx_rtmp_kmp_api_upstream_json_write(p, cur);
    }

    p = ngx_copy(p, "]}", sizeof("]}") - 1);

    return p;
}

static size_t
ngx_rtmp_kmp_api_audio_track_json_get_size(ngx_kmp_push_track_t *obj,
    ngx_rtmp_codec_ctx_t *codec_ctx)
{
    ngx_queue_t  *q;
    size_t result =
        sizeof("{\"input_id\":\"") - 1 + obj->input_id.len +
            ngx_escape_json(NULL, obj->input_id.data, obj->input_id.len) +
        sizeof("\",\"channel_id\":\"") - 1 + obj->channel_id.len +
            ngx_escape_json(NULL, obj->channel_id.data, obj->channel_id.len) +
        sizeof("\",\"track_id\":\"") - 1 + obj->track_id.len +
            ngx_escape_json(NULL, obj->track_id.data, obj->track_id.len) +
        sizeof("\",\"mem_left\":") - 1 + NGX_SIZE_T_LEN +
        sizeof(",\"mem_limit\":") - 1 + NGX_SIZE_T_LEN +
        sizeof(",\"codec_info\":") - 1 +
            ngx_rtmp_kmp_api_audio_codec_info_json_get_size(codec_ctx) +
        sizeof(",\"upstreams\":[") - 1 +
        sizeof("]}") - 1;

    for (q = ngx_queue_head(&obj->upstreams);
        q != ngx_queue_sentinel(&obj->upstreams);
        q = ngx_queue_next(q))
    {
        ngx_kmp_push_upstream_t *cur = ngx_queue_data(q,
            ngx_kmp_push_upstream_t, queue);
        result += ngx_rtmp_kmp_api_upstream_json_get_size(cur) + sizeof(",") -
            1;
    }

    return result;
}

static u_char *
ngx_rtmp_kmp_api_audio_track_json_write(u_char *p, ngx_kmp_push_track_t *obj,
    ngx_rtmp_codec_ctx_t *codec_ctx)
{
    ngx_queue_t  *q;
    p = ngx_copy(p, "{\"input_id\":\"", sizeof("{\"input_id\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, obj->input_id.data, obj->input_id.len);
    p = ngx_copy(p, "\",\"channel_id\":\"", sizeof("\",\"channel_id\":\"") -
        1);
    p = (u_char *) ngx_escape_json(p, obj->channel_id.data,
        obj->channel_id.len);
    p = ngx_copy(p, "\",\"track_id\":\"", sizeof("\",\"track_id\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, obj->track_id.data, obj->track_id.len);
    p = ngx_copy(p, "\",\"mem_left\":", sizeof("\",\"mem_left\":") - 1);
    p = ngx_sprintf(p, "%uz", (size_t) obj->mem_left);
    p = ngx_copy(p, ",\"mem_limit\":", sizeof(",\"mem_limit\":") - 1);
    p = ngx_sprintf(p, "%uz", (size_t) obj->mem_limit);
    p = ngx_copy(p, ",\"codec_info\":", sizeof(",\"codec_info\":") - 1);
    p = ngx_rtmp_kmp_api_audio_codec_info_json_write(p, codec_ctx);
    p = ngx_copy(p, ",\"upstreams\":[", sizeof(",\"upstreams\":[") - 1);

    for (q = ngx_queue_head(&obj->upstreams);
        q != ngx_queue_sentinel(&obj->upstreams);
        q = ngx_queue_next(q))
    {
        ngx_kmp_push_upstream_t *cur = ngx_queue_data(q,
            ngx_kmp_push_upstream_t, queue);

        if (q != ngx_queue_head(&obj->upstreams)) {
            *p++ = ',';
        }
        p = ngx_rtmp_kmp_api_upstream_json_write(p, cur);
    }

    p = ngx_copy(p, "]}", sizeof("]}") - 1);

    return p;
}

static size_t
ngx_rtmp_kmp_api_stream_json_get_size(ngx_rtmp_kmp_stream_ctx_t *obj,
    ngx_rtmp_live_stream_t *stream, ngx_rtmp_codec_ctx_t *codec_ctx)
{
    size_t result =
        sizeof("{\"name\":\"") - 1 + obj->publish.name.len +
            ngx_escape_json(NULL, obj->publish.name.data,
            obj->publish.name.len) +
        sizeof("\",\"args\":\"") - 1 + obj->publish.args.len +
            ngx_escape_json(NULL, obj->publish.args.data,
            obj->publish.args.len) +
        sizeof("\",\"type\":\"") - 1 + obj->publish.type.len +
            ngx_escape_json(NULL, obj->publish.type.data,
            obj->publish.type.len) +
        sizeof("\",\"bw_in\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"bytes_in\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"bw_in_audio\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"bytes_in_audio\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"bw_in_video\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"bytes_in_video\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"bw_out\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"bytes_out\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"time\":") - 1 + NGX_INT_T_LEN +
        sizeof(",\"tracks\":{") - 1 +
            ngx_rtmp_kmp_api_tracks_json_get_size(obj->tracks, codec_ctx) +
        sizeof("}}") - 1;

    return result;
}

static u_char *
ngx_rtmp_kmp_api_stream_json_write(u_char *p, ngx_rtmp_kmp_stream_ctx_t *obj,
    ngx_rtmp_live_stream_t *stream, ngx_rtmp_codec_ctx_t *codec_ctx)
{
    p = ngx_copy(p, "{\"name\":\"", sizeof("{\"name\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, obj->publish.name.data,
        obj->publish.name.len);
    p = ngx_copy(p, "\",\"args\":\"", sizeof("\",\"args\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, obj->publish.args.data,
        obj->publish.args.len);
    p = ngx_copy(p, "\",\"type\":\"", sizeof("\",\"type\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, obj->publish.type.data,
        obj->publish.type.len);
    p = ngx_copy(p, "\",\"bw_in\":", sizeof("\",\"bw_in\":") - 1);
    p = ngx_sprintf(p, "%uL", (uint64_t) (stream->bw_in.bandwidth * 8));
    p = ngx_copy(p, ",\"bytes_in\":", sizeof(",\"bytes_in\":") - 1);
    p = ngx_sprintf(p, "%uL", (uint64_t) stream->bw_in.bytes);
    p = ngx_copy(p, ",\"bw_in_audio\":", sizeof(",\"bw_in_audio\":") - 1);
    p = ngx_sprintf(p, "%uL", (uint64_t) (stream->bw_in_audio.bandwidth * 8));
    p = ngx_copy(p, ",\"bytes_in_audio\":", sizeof(",\"bytes_in_audio\":") -
        1);
    p = ngx_sprintf(p, "%uL", (uint64_t) stream->bw_in_audio.bytes);
    p = ngx_copy(p, ",\"bw_in_video\":", sizeof(",\"bw_in_video\":") - 1);
    p = ngx_sprintf(p, "%uL", (uint64_t) (stream->bw_in_video.bandwidth * 8));
    p = ngx_copy(p, ",\"bytes_in_video\":", sizeof(",\"bytes_in_video\":") -
        1);
    p = ngx_sprintf(p, "%uL", (uint64_t) stream->bw_in_video.bytes);
    p = ngx_copy(p, ",\"bw_out\":", sizeof(",\"bw_out\":") - 1);
    p = ngx_sprintf(p, "%uL", (uint64_t) (stream->bw_out.bandwidth * 8));
    p = ngx_copy(p, ",\"bytes_out\":", sizeof(",\"bytes_out\":") - 1);
    p = ngx_sprintf(p, "%uL", (uint64_t) stream->bw_out.bytes);
    p = ngx_copy(p, ",\"time\":", sizeof(",\"time\":") - 1);
    p = ngx_sprintf(p, "%i", (ngx_int_t) (ngx_current_msec - stream->epoch));
    p = ngx_copy(p, ",\"tracks\":{", sizeof(",\"tracks\":{") - 1);
    p = ngx_rtmp_kmp_api_tracks_json_write(p, obj->tracks, codec_ctx);
    p = ngx_copy(p, "}}", sizeof("}}") - 1);

    return p;
}

static size_t
ngx_rtmp_kmp_api_session_json_get_size(ngx_rtmp_kmp_ctx_t *obj)
{
    ngx_rtmp_session_t *s = obj->s;
    size_t result =
        sizeof("{\"flashver\":\"") - 1 + s->flashver.len +
            ngx_escape_json(NULL, s->flashver.data, s->flashver.len) +
        sizeof("\",\"swf_url\":\"") - 1 + s->swf_url.len +
            ngx_escape_json(NULL, s->swf_url.data, s->swf_url.len) +
        sizeof("\",\"tc_url\":\"") - 1 + s->tc_url.len + ngx_escape_json(NULL,
            s->tc_url.data, s->tc_url.len) +
        sizeof("\",\"page_url\":\"") - 1 + s->page_url.len +
            ngx_escape_json(NULL, s->page_url.data, s->page_url.len) +
        sizeof("\",\"remote_addr\":\"") - 1 + obj->remote_addr.len +
            ngx_escape_json(NULL, obj->remote_addr.data, obj->remote_addr.len)
            +
        sizeof("\",\"time\":") - 1 + NGX_INT_T_LEN +
        sizeof(",\"connection\":") - 1 + NGX_INT_T_LEN +
        sizeof(",\"streams\":[") - 1 +
            ngx_rtmp_kmp_api_streams_json_get_size(s) +
        sizeof("]}") - 1;

    return result;
}

static u_char *
ngx_rtmp_kmp_api_session_json_write(u_char *p, ngx_rtmp_kmp_ctx_t *obj)
{
    ngx_rtmp_session_t *s = obj->s;
    p = ngx_copy(p, "{\"flashver\":\"", sizeof("{\"flashver\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, s->flashver.data, s->flashver.len);
    p = ngx_copy(p, "\",\"swf_url\":\"", sizeof("\",\"swf_url\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, s->swf_url.data, s->swf_url.len);
    p = ngx_copy(p, "\",\"tc_url\":\"", sizeof("\",\"tc_url\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, s->tc_url.data, s->tc_url.len);
    p = ngx_copy(p, "\",\"page_url\":\"", sizeof("\",\"page_url\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, s->page_url.data, s->page_url.len);
    p = ngx_copy(p, "\",\"remote_addr\":\"", sizeof("\",\"remote_addr\":\"") -
        1);
    p = (u_char *) ngx_escape_json(p, obj->remote_addr.data,
        obj->remote_addr.len);
    p = ngx_copy(p, "\",\"time\":", sizeof("\",\"time\":") - 1);
    p = ngx_sprintf(p, "%i", (ngx_int_t) (ngx_current_msec - s->epoch));
    p = ngx_copy(p, ",\"connection\":", sizeof(",\"connection\":") - 1);
    p = ngx_sprintf(p, "%uA", (ngx_atomic_uint_t) s->connection->number);
    p = ngx_copy(p, ",\"streams\":[", sizeof(",\"streams\":[") - 1);
    p = ngx_rtmp_kmp_api_streams_json_write(p, s);
    p = ngx_copy(p, "]}", sizeof("]}") - 1);

    return p;
}

static size_t
ngx_rtmp_kmp_api_application_json_get_size(ngx_rtmp_core_app_conf_t *obj)
{
    ngx_queue_t  *q;
    ngx_rtmp_kmp_app_conf_t *kacf =
        obj->app_conf[ngx_rtmp_kmp_module.ctx_index];
    if (kacf == NULL) {
        return 0;
    }
    size_t result =
        sizeof("{\"name\":\"") - 1 + obj->name.len + ngx_escape_json(NULL,
            obj->name.data, obj->name.len) +
        sizeof("\",\"sessions\":[") - 1 +
        sizeof("]}") - 1;

    for (q = ngx_queue_head(&kacf->sessions);
        q != ngx_queue_sentinel(&kacf->sessions);
        q = ngx_queue_next(q))
    {
        ngx_rtmp_kmp_ctx_t *cur = ngx_queue_data(q, ngx_rtmp_kmp_ctx_t, queue);
        result += ngx_rtmp_kmp_api_session_json_get_size(cur) + sizeof(",") -
            1;
    }

    return result;
}

static u_char *
ngx_rtmp_kmp_api_application_json_write(u_char *p, ngx_rtmp_core_app_conf_t
    *obj)
{
    ngx_queue_t  *q;
    ngx_rtmp_kmp_app_conf_t *kacf =
        obj->app_conf[ngx_rtmp_kmp_module.ctx_index];
    if (kacf == NULL) {
        return p;
    }
    p = ngx_copy(p, "{\"name\":\"", sizeof("{\"name\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, obj->name.data, obj->name.len);
    p = ngx_copy(p, "\",\"sessions\":[", sizeof("\",\"sessions\":[") - 1);

    for (q = ngx_queue_head(&kacf->sessions);
        q != ngx_queue_sentinel(&kacf->sessions);
        q = ngx_queue_next(q))
    {
        ngx_rtmp_kmp_ctx_t *cur = ngx_queue_data(q, ngx_rtmp_kmp_ctx_t, queue);

        if (q != ngx_queue_head(&kacf->sessions)) {
            *p++ = ',';
        }
        p = ngx_rtmp_kmp_api_session_json_write(p, cur);
    }

    p = ngx_copy(p, "]}", sizeof("]}") - 1);

    return p;
}

static size_t
ngx_rtmp_kmp_api_server_json_get_size(ngx_rtmp_core_srv_conf_t *obj)
{
    ngx_uint_t  n;
    size_t result =
        sizeof("{\"applications\":[") - 1 +
        sizeof("]}") - 1;

    for (n = 0; n < obj->applications.nelts; ++n) {
        ngx_rtmp_core_app_conf_t* cur =
            ((ngx_rtmp_core_app_conf_t**)obj->applications.elts)[n];
        result += ngx_rtmp_kmp_api_application_json_get_size(cur) +
            sizeof(",") - 1;
    }

    return result;
}

static u_char *
ngx_rtmp_kmp_api_server_json_write(u_char *p, ngx_rtmp_core_srv_conf_t *obj)
{
    ngx_uint_t  n;
    p = ngx_copy(p, "{\"applications\":[", sizeof("{\"applications\":[") - 1);

    for (n = 0; n < obj->applications.nelts; ++n) {
        ngx_rtmp_core_app_conf_t* cur =
            ((ngx_rtmp_core_app_conf_t**)obj->applications.elts)[n];

        if (n > 0) {
            *p++ = ',';
        }
        p = ngx_rtmp_kmp_api_application_json_write(p, cur);
    }

    p = ngx_copy(p, "]}", sizeof("]}") - 1);

    return p;
}

static size_t
ngx_rtmp_kmp_api_json_get_size()
{
    ngx_uint_t  n;
    ngx_rtmp_core_main_conf_t *cmcf = ngx_rtmp_core_main_conf;
    size_t result =
        sizeof("{\"version\":\"") - 1 + ngx_rtmp_kmp_version.len +
            ngx_escape_json(NULL, ngx_rtmp_kmp_version.data,
            ngx_rtmp_kmp_version.len) +
        sizeof("\",\"nginx_version\":\"") - 1 + ngx_rtmp_kmp_nginx_version.len
            + ngx_escape_json(NULL, ngx_rtmp_kmp_nginx_version.data,
            ngx_rtmp_kmp_nginx_version.len) +
        sizeof("\",\"rtmp_version\":\"") - 1 + ngx_rtmp_kmp_rtmp_version.len +
            ngx_escape_json(NULL, ngx_rtmp_kmp_rtmp_version.data,
            ngx_rtmp_kmp_rtmp_version.len) +
        sizeof("\",\"compiler\":\"") - 1 + ngx_rtmp_kmp_compiler.len +
            ngx_escape_json(NULL, ngx_rtmp_kmp_compiler.data,
            ngx_rtmp_kmp_compiler.len) +
        sizeof("\",\"built\":\"") - 1 + ngx_rtmp_kmp_built.len +
            ngx_escape_json(NULL, ngx_rtmp_kmp_built.data,
            ngx_rtmp_kmp_built.len) +
        sizeof("\",\"pid\":") - 1 + NGX_INT_T_LEN +
        sizeof(",\"uptime\":") - 1 + NGX_INT_T_LEN +
        sizeof(",\"naccepted\":") - 1 + NGX_INT_T_LEN +
        sizeof(",\"bw_in\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"bytes_in\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"bw_out\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"bytes_out\":") - 1 + NGX_INT64_LEN +
        sizeof(",\"servers\":[") - 1 +
        sizeof("]}") - 1;

    for (n = 0; n < cmcf->servers.nelts; ++n) {
        ngx_rtmp_core_srv_conf_t* cur =
            ((ngx_rtmp_core_srv_conf_t**)cmcf->servers.elts)[n];
        result += ngx_rtmp_kmp_api_server_json_get_size(cur) + sizeof(",") - 1;
    }

    return result;
}

static u_char *
ngx_rtmp_kmp_api_json_write(u_char *p)
{
    ngx_uint_t  n;
    ngx_rtmp_core_main_conf_t *cmcf = ngx_rtmp_core_main_conf;
    p = ngx_copy(p, "{\"version\":\"", sizeof("{\"version\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, ngx_rtmp_kmp_version.data,
        ngx_rtmp_kmp_version.len);
    p = ngx_copy(p, "\",\"nginx_version\":\"",
        sizeof("\",\"nginx_version\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, ngx_rtmp_kmp_nginx_version.data,
        ngx_rtmp_kmp_nginx_version.len);
    p = ngx_copy(p, "\",\"rtmp_version\":\"", sizeof("\",\"rtmp_version\":\"")
        - 1);
    p = (u_char *) ngx_escape_json(p, ngx_rtmp_kmp_rtmp_version.data,
        ngx_rtmp_kmp_rtmp_version.len);
    p = ngx_copy(p, "\",\"compiler\":\"", sizeof("\",\"compiler\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, ngx_rtmp_kmp_compiler.data,
        ngx_rtmp_kmp_compiler.len);
    p = ngx_copy(p, "\",\"built\":\"", sizeof("\",\"built\":\"") - 1);
    p = (u_char *) ngx_escape_json(p, ngx_rtmp_kmp_built.data,
        ngx_rtmp_kmp_built.len);
    p = ngx_copy(p, "\",\"pid\":", sizeof("\",\"pid\":") - 1);
    p = ngx_sprintf(p, "%ui", (ngx_uint_t) ngx_getpid());
    p = ngx_copy(p, ",\"uptime\":", sizeof(",\"uptime\":") - 1);
    p = ngx_sprintf(p, "%i", (ngx_int_t) (ngx_cached_time->sec -
        ngx_rtmp_kmp_start_time));
    p = ngx_copy(p, ",\"naccepted\":", sizeof(",\"naccepted\":") - 1);
    p = ngx_sprintf(p, "%ui", (ngx_uint_t) ngx_rtmp_naccepted);
    p = ngx_copy(p, ",\"bw_in\":", sizeof(",\"bw_in\":") - 1);
    p = ngx_sprintf(p, "%uL", (uint64_t) (ngx_rtmp_bw_in.bandwidth * 8));
    p = ngx_copy(p, ",\"bytes_in\":", sizeof(",\"bytes_in\":") - 1);
    p = ngx_sprintf(p, "%uL", (uint64_t) ngx_rtmp_bw_in.bytes);
    p = ngx_copy(p, ",\"bw_out\":", sizeof(",\"bw_out\":") - 1);
    p = ngx_sprintf(p, "%uL", (uint64_t) (ngx_rtmp_bw_out.bandwidth * 8));
    p = ngx_copy(p, ",\"bytes_out\":", sizeof(",\"bytes_out\":") - 1);
    p = ngx_sprintf(p, "%uL", (uint64_t) ngx_rtmp_bw_out.bytes);
    p = ngx_copy(p, ",\"servers\":[", sizeof(",\"servers\":[") - 1);

    for (n = 0; n < cmcf->servers.nelts; ++n) {
        ngx_rtmp_core_srv_conf_t* cur =
            ((ngx_rtmp_core_srv_conf_t**)cmcf->servers.elts)[n];

        if (n > 0) {
            *p++ = ',';
        }
        p = ngx_rtmp_kmp_api_server_json_write(p, cur);
    }

    p = ngx_copy(p, "]}", sizeof("]}") - 1);

    return p;
}
